import { Cryptography, Hashing } from "@demosdk/encryption"
import {
    BridgeOperation,
    BridgeOperationCompiled,
    SupportedChain,
    SupportedEVMChain,
    SupportedStablecoin,
    supportedEVMChains,
    SupportedNonEVMChain,
    supportedNonEVMChains,
} from "./nativeBridgeTypes"
import { RPCRequest } from "@demosdk/types"
import type { Demos } from "@demosdk/websdk"
import type { Transaction } from "@demosdk/types"

export const methods = {
    /**
     * Validates the chain
     * @param chain
     * @param chainType
     * @param isOrigin (useful for error messages)
     */
    validateChain (
        chain: string,
        chainType: string,
        isOrigin: boolean,
    ) {
        const chainTypeStr = isOrigin ? "origin" : "destination"
        if (chainType === "EVM") {
            if (!supportedEVMChains.includes(chain as SupportedEVMChain)) {
                throw new Error(
                    `Invalid ${chainTypeStr} chain: ${chain} is not a supported EVM`,
                )
            }
        } else {
            if (
                !supportedNonEVMChains.includes(
                    chain as SupportedNonEVMChain,
                )
            ) {
                throw new Error(
                    `Invalid ${chainTypeStr} chain: ${chain} is not a supported chain`,
                )
            }
        }
    },
    /**
     * Generates a new operation, ready to be sent to the node as a RPCRequest
     * TODO Implement the params
     * REVIEW Should we use the identity somehow or we keep using the private key?
     */
    generateOperation(
        privateKey: string,
        publicKey: string,
        originChainType: SupportedChain,
        originChain: SupportedEVMChain | SupportedNonEVMChain,
        destinationChainType: SupportedChain,
        destinationChain: SupportedEVMChain | SupportedNonEVMChain,
        originAddress: string,
        destinationAddress: string,
        amount: string,
        token: SupportedStablecoin,
    ): RPCRequest {
        // Ensuring the chains are valid: throw an error if not
        this.validateChain(originChain, originChainType, true)
        this.validateChain(destinationChain, destinationChainType, false)
        // Defining the operation
        const operation: BridgeOperation = {
            demoAddress: publicKey,
            originChainType: originChainType,
            originChain: originChain,
            destinationChainType: destinationChainType,
            destinationChain: destinationChain,
            originAddress: originAddress,
            destinationAddress: destinationAddress,
            amount: amount,
            token: token,
            txHash: "",
            status: "empty",
        }
        // REVIEW Sign the operation
        let opHash = Hashing.sha256(JSON.stringify(operation))
        let signature = Cryptography.sign(opHash, privateKey)
        let hexSignature = new TextDecoder().decode(signature)
        let nodeCallPayload: RPCRequest = {
            method: "nativeBridge",
            params: [operation, hexSignature],
        }
        return nodeCallPayload
    },

    /**
     * Generates a bridge transaction ready for client confirmation and broadcasting.
     * 
     * @param compiled - The compiled bridge operation from RPC
     * @param demos - Demos instance for signing (provides wallet and nonce)
     * @returns Signed transaction ready for demos.confirm() and demos.broadcast()
     */
    async generateOperationTx(compiled: BridgeOperationCompiled, demos: Demos): Promise<Transaction> {
        // Extract addresses from the compiled operation
        const operation = compiled.content.operation
        const from = operation.originAddress      // Source chain address
        const to = operation.originAddress        // Same as from (reflexive transaction)
        const from_ed25519_address = operation.demoAddress  // Demos address that started operation
        
        // Get proper nonce from demos instance
        const nonce = await demos.getAddressNonce(from_ed25519_address)
        
        // Prepare the transaction structure
        const tx: Transaction = {
            content: {
                type: "nativeBridge",
                data: ["nativeBridge", compiled],
                from: from,
                to: to,
                from_ed25519_address: from_ed25519_address,
                amount: 0,  // Always 0 for bridge operations
                gcr_edits: [],  // Will be generated by demos.sign()
                nonce: nonce + 1,
                timestamp: Date.now(),
                transaction_fee: {
                    network_fee: 0,
                    rpc_fee: 0,
                    additional_fee: 0,
                },
            },
            signature: {
                type: "ed25519",
                data: "",
            },
            hash: "",
            status: "empty",
            blockNumber: 0,
            ed25519_signature: ""
        }
        
        // Use demos.sign() which handles GCR generation, hashing, and signing
        const signedTx = await demos.sign(tx)
        
        // NOTE: Client must call demos.confirm(signedTx) then demos.broadcast(validationData)
        // to complete the transaction flow, following the same pattern as pay() transactions
        return signedTx
    },
}
