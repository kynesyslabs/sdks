Hi ðŸ‘‹

A XMScript is made up of these components:

1. Work steps
2. Operations
3. The operation order

### Work steps

A work step can either be a web2, xm or a native transaction. Say for example, sending tokens on Ethereum or calling a web2 API.

A work step generally looks like this:

```ts
class WorkStep {
    type: "xm" | "web2" | "native"
    workUID: string
    input: WorkStepInput
    output: any
    description: string

    hash: string
    signature: Uint8Array

    sign(privateKey: any): Uint8Array
    execute(): WorkStepOutput
}
```

The output of a workstep indicated above is not the result of executing the step. Since we don't have that value yet, the output is represented as objects that operations can use to refer to the future/actual output of the step.

For instance, here's how the web2 step output is defined:

_@/demoswork/workstep.ts_

```ts
class Web2WorkStep extends WorkStep {
    output: any = {
        statusCode: {
            type: "internal",
            src: {
                stepUID: this.workUID,
                key: "output.statusCode",
            },
        },
        payload: {
            type: "internal",
            src: {
                stepUID: this.workUID,
                key: "output.payload",
            },
        },
    }
}
```

When executing an operation that needs an output of a step, that step will be executed and its result parsed using the key specified to get the value.

### Operations

An operation controls the execution of steps therefore enabling scripting on the omniweb.

An operation can be a conditional, a loop or something else. I used the conditional operation to set up the ground work.

An operation generally looks like this:

```ts
class Operation {
    operationUID: string
    operationType: "conditional" | "loop" | ...
}
```

A conditional operation now builds on top of that:

_@/demoswork/operations/conditional.ts_

```ts
interface Condition {
    operator: string
    key: string
    value: any
    stepUID: string
    do: string
}

class Conditional extends Operation {
    conditions: Condition[]

    then(step: WorkStep) {
        return {
            elif: this.elif,
            else: this.else,
        }
    }

    elif(condition: ConditionWithStep) {
        return {
            then: this.then,
        }
    }

    else(): void
}
```

After constructing an operation, it adds the referred steps and writes itself to the XMScript.

### The Operation Order

This is an ordered list of Operation UID strings. It dictates the order in which the operations in a script are supposed to be executed.

### Conditonal Operators

To create rules with operators using work step values, we use utility functions to create data structures that we can put in the script.

For example:

```ts
function equalTo(step: WorkStep, key: stepKeys, value: any) {
    return {
        step: step,
        operator: "equality",
        key: key,
        value: value,
    }
}
```

### The DemosWork class

The `DemosWork` class is the starting point of creating a XMScript. It exposes methods to construct the XMScript.

It currently looks like this:

```ts
class DemosWork {
    script: XMScript = {
        steps: {},
        operations: {},
        operationOrder: new Set<string>(),
    }

    if(condition: Condition) {
        return new Conditional(this.script, condition)
    }

    // more operation go here

    toJSON(): JSON<XMScript>{}
}
```

You can find the implementations of the above in the `@/demoswork` directory in the `demoswork` branch.

### Example usage

You can create a XMScript with a conditional operation using the following code:

```ts
const work = new DemosWork()

// INFO: Create work steps
const sendEth = new XmWorkStep("payload")
sendEth.description = "Send ETH"

const sendMoreEth = new XmWorkStep("payload")
sendMoreEth.description = "Send more ETH"

const sendHash = new Web2WorkStep({
    url: "https://myapi.com",
    method: "POST",
    data: {
        hash: sendEth.output.hash,
    },
})
sendHash.description = "Send xm hash to HTTP API"

// INFO: Construct a conditional operation
//              WorkStep | Workstep property | value
work.if(equalTo(sendEth, "output.result", XmStepResult.success))
    .then(sendHash)
    .elif(equalTo(sendEth, "output.result", XmStepResult.error))
    .then(sendHash)
    .else(sendHash)

// This would be the final script
pprint(work.toJSON())
```

### Running tests

To view the script generated by the above code, run:

```sh
yarn install

yarn test:demoswork
```
